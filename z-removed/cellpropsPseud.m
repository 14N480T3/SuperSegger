function info = cellpropsPseud ( mask, props )
% cellpropsPseud : Calculates the shape properties of the region or 'cell'
% for Pseudemonas cells. It calculates 8 properties info = [L1,L2max,Lneck,L2mean, stm, RoundIndOver, RoundIndUnder, Area];
%
% INPUT :
%       mask : cell / region mask
%       props : properties generated by regionprops
% OUTPUT :
%       info : array with 8 quantities : 
%       [L1, L2max, Lneck, L2mean, stm, RoundIndOver, RoundIndUnder, Area];
%
%
% Copyright (C) 2016 Wiggins Lab
% Written by Paul Wiggins.
% University of Washington, 2016
% This file is part of SuperSegger.
%
% SuperSegger is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% SuperSegger is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with SuperSegger.  If not, see <http://www.gnu.org/licenses/>.

Orientation = props.Orientation;
debug = false;
dr  = 5;
dr2 = 3;
imRot = double(imrotate( uint8(mask), -Orientation+90 ));
ss = size(imRot);

if debug
    clf;
    imshow(cat(3,ag(imRot)+0.5*ag(~imRot),ag(imRot),ag(imRot)));
    hold on;
end

width = sum(imRot,2);
ymask = logical(width>=1);
widthWindow = ([0;width(1:end-1)] + width + [width(2:end);0] )/3;

L1 = sum(ymask);
L2max = max(widthWindow);

y = 1:ss(1);
x = 1:ss(2);

ymin = min(y(ymask));
ymax = max(y(ymask));

L2mean = mean(width((ymin):(ymax)));
minStep = 1;
[ws,num_ws] = watershedNoise(widthWindow, minStep);

if num_ws > 2
    ind = find(ismember( ws,2:(num_ws-1)));
    [Lneck,pos] = min(widthWindow(ind));
    pos = ind(pos);
    
    if debug
        plot( x,x*0+pos, 'r:' );
    end
else
    Lneck = L2mean;
    pos = mean([ymin,ymax]);
    if debug
        plot( x,x*0+pos, 'k:' );
    end
end

yy = (ymin+dr):dr2:(ymax-dr);

if numel(yy) > 4
    tmp = imRot(yy,:);
    
    [X,Y] = meshgrid(x,yy);
    
    xx = sum( X.*tmp,2 )./sum(tmp,2);
    
    d1 = [xx(1:end-2)-xx(3:end),yy(1:end-2)'-yy(3:end)'];
    
    stm = abs((d1(1:end-2,1).*d1(3:end,2)...
        -d1(1:end-2,2).*d1(3:end,1))./...
        (norm2(d1(1:end-2,:)).*norm2(d1(3:end,:))));
    
    stm = max( stm );
    
    if debug
        ss_ = size(d1);
        for ii = 1:ss_(1)
            plot( xx(ii)+[0,-d1(ii,1)], yy(ii)+[0,-d1(ii,2)], 'c.' );
        end
    end
    
    yy = [(ymin+dr),(ymax-dr)];
    xx = widthWindow(round(yy));
    r = ((xx)/2);
    
    
    yyd = [(ymin+r(1)+[-1,0,1]),(ymax-r(2)+[-1,0,1])];
    yy  = round(yyd);
    
    [X,Y] = meshgrid(x,yy);
    tmp = imRot(yy,:);
    xx = sum( X.*tmp,2 )./sum(tmp,2);
    xx = [mean(xx(1:3)),mean(xx(4:6))];
    yyd = yyd([2,5]);
    yy  = yy([2,5]);
    
    if debug
        phi = 0:.1:2*pi;
        
        plot(xx,yyd,'go');
        xxx = r(1)*cos(phi);
        yyy = r(1)*sin(phi);
        plot(xx(1)+xxx,yy(1)+yyy,'g:')
        
        xxx = r(2)*cos(phi);
        yyy = r(2)*sin(phi);
        plot(xx(2)+xxx,yyd(2)+yyy,'g:')
        
        plot( [1,ss(2)],[ymax,ymax],':r')
        plot( [1,ss(2)],[ymin,ymin],':r')
        
    end
    
    xcen = xx;
    ycen = yyd;
    
    x0 = xcen(1);
    y0 = ycen(1);
    r0 = r(1);
    
    yy = max(1,round(y0-r0-2)):min(round(y0+r0+2),ss(1));
    xx = max(1,round(x0-r0-2)):min(round(x0+r0+2),ss(2));
    
    [X,Y] = meshgrid(xx,yy);
    tmp = imRot(yy,xx);
    
    R2 = (X-x0).^2 + (Y-y0).^2 - r0^2;
    
    ind_over = find( ((R2 > 0).*tmp).*(d1(1,1)*(X-x0) + d1(1,2)*(Y-y0) > 0));
    ind_under = find( ((R2 < 0).*(tmp<1)).*(d1(1,1)*(X-x0) + d1(1,2)*(Y-y0) > 0));
    
    
    if debug
        plot(X(ind_over),Y(ind_over),'r.');
        plot(X(ind_under),Y(ind_under),'b.');
    end
    
    RoundIndOverTop  = sum( tmp(ind_over).*R2(ind_over))/r0^4;
    RoundIndUnderTop = sum( (1-tmp(ind_under)).*abs(R2(ind_under)))/r0^4;
    
    x0 = xcen(2);
    y0 = ycen(2);
    r0 = r(2);
    
    yy = max(1,round(y0-r0-2)):min(round(y0+r0+2),ss(1));
    xx = max(1,round(x0-r0-2)):min(round(x0+r0+2),ss(2));
    
    [X,Y] = meshgrid(xx,yy);
    tmp = imRot(yy,xx);
    
    R2 = (X-x0).^2 + (Y-y0).^2 - r0^2;
    
    ind_over = find( ((R2 > 0).*tmp).*(d1(1,1)*(X-x0) + d1(1,2)*(Y-y0) < 0));
    ind_under = find( ((R2 < 0).*(tmp<1)).*(d1(1,1)*(X-x0) + d1(1,2)*(Y-y0) < 0));
    
    if debug
        plot(X(ind_over),Y(ind_over),'r.');
        plot(X(ind_under),Y(ind_under),'b.');
    end
    
    
    RoundIndOverBot  = sum( tmp(ind_over).*R2(ind_over))/r0^4;
    RoundIndUnderBot = sum( (1-tmp(ind_under)).*abs(R2(ind_under)))/r0^4;
    
else
    %'fail'
    stm = 0;
    RoundIndOverTop  = 0;
    RoundIndUnderTop = 0;
    RoundIndOverBot  = 0;
    RoundIndUnderBot = 0;
    
end



RoundIndOver  = RoundIndOverTop  + RoundIndOverBot;
RoundIndUnder = RoundIndUnderTop + RoundIndUnderBot;


Area = sum(double(logical(mask(:))));
info = [L1,L2max,Lneck,L2mean, stm, RoundIndOver, RoundIndUnder, Area];
info(isnan(info)) = 0;

end

function tmp = norm2( dd )
tmp = sqrt(sum(dd.*dd,2));
end
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of trackOptiMakeCell</title>
  <meta name="keywords" content="trackOptiMakeCell">
  <meta name="description" content="trackOptiMakeCell generates the CellA field indexed by the region number">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">SuperSeggerOpti_Release</a> &gt; <a href="index.html">cell</a> &gt; trackOptiMakeCell.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for SuperSeggerOpti_Release/cell&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>trackOptiMakeCell
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>trackOptiMakeCell generates the CellA field indexed by the region number</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function trackOptiMakeCell(dirname,CONST,header) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> trackOptiMakeCell generates the CellA field indexed by the region number
 which contains information about each cell in each region in each frame.

 It goes through the dirname/*err.mat files and computes the characteristics of the
 cells in each frame and puts them in the CellA structure that is indexed
 by the region number, not the cell ID. This code figures out the pole
 age and also computes statistics on the fluorescence channels as
 well as fitting the locus positions. These last two features are
 controlled by parameters set in the loadConstants.m or
 loadConstantsMine.m files.  numSpots variable in no longer used.

 data.CellA{1}.
           mask        : logical (1 and 0) cell mask, unoriented
             r_offset    : location of cell in full image from top left corner
             BB          : coordinates of cell bounding box, containing the
             cell and the pad
             edgeFlag    : if the cell is on the edge of the image (bad)
             phase        : the cropped phase image of the cell
             coord        : coordinates, area, and orientation, see below
             length        : (1) length and (2) width of the cell
             pole        : orientation of the cell pole, see below
             fluor1        : the 1st fluor channel image
             fuor1mm     : min and max of fluor1
             fl1         : statistics of fluor1, e.g. background level
             fluor2        : the 2nd fluor channel image
             fluor2mm    : min and max of fluor2
             fl2         : statistics of fluor2
             cell_dist    : ?
             gray        : ?
             locus1        : If focus fitting was run, data on the fit
             (locations, score..), see below
             locus2        : Same as above for channel 2
             r           : global coordinates of cell centroid (mid-point of cell)
             error        : segmentation error list
             ehist        : ehist is the sum of all errors in the region?s history
           contactHist    : ?
           stat0        : stat0 flag that is true if the cell is born without error

 The coord field contains a lot of cell specific info:
 data.CellA{1}.coord =
         A: Area of cell mask
         r_center: geometrical center of the cell
         box: coord of box surrounding cell
         xaxis: coord of major axis
         yaxis:  coord of minor axis
         I: Moment of inertia of cell mask
         e1: priniple axis (major) unit vector
         e2: priniple axis (minor) unit vector
         rcm: center of ?mass? position of mask

 The pole field contains info pertaining to the cell pole and pole ages:
 data.CellA{1}.pole =
        e1: major axis direction.
        op_ori: 1 if old pole is in direction of e1
             -1 if old pole is in opposite e1
        op_age: age of old pole in cell cycles
             NaN if no birth is observed
        np_age: age of new pole in cell cycles

 The locus field contains info from locus finding - if it is run.
 data.CellA{1}.locus1(1) =
       r: Spot position in global coords
       score: score from spot fit.
       intensity: raw intensity
       b: spot width from fit
       shortaxis: Locus position in local coords (short axis)
       longaxis: Spot position in local coords (long axis)

 INPUT :
       dirname: seg folder eg. maindirectory/xy1/seg
       CONST: are the segmentation constants.
       header : string displayed with information

 Copyright (C) 2016 Wiggins Lab
 University of Washington, 2016
 This file is part of SuperSeggerOpti.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="makeColonyDist.html" class="code" title="function dist_mask = makeColonyDist( mask )">makeColonyDist</a>	makeColonyDist : returns the distance mask for the colony</li><li><a href="toMakeCell.html" class="code" title="function celld = toMakeCell(celld, e1_old, props)">toMakeCell</a>	toMakeCell calls toMakeCellFast to calculates the properties of the cell.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function data = loaderInternal(filename);</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function trackOptiMakeCell(dirname,CONST,header)</a>
0002 <span class="comment">% trackOptiMakeCell generates the CellA field indexed by the region number</span>
0003 <span class="comment">% which contains information about each cell in each region in each frame.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% It goes through the dirname/*err.mat files and computes the characteristics of the</span>
0006 <span class="comment">% cells in each frame and puts them in the CellA structure that is indexed</span>
0007 <span class="comment">% by the region number, not the cell ID. This code figures out the pole</span>
0008 <span class="comment">% age and also computes statistics on the fluorescence channels as</span>
0009 <span class="comment">% well as fitting the locus positions. These last two features are</span>
0010 <span class="comment">% controlled by parameters set in the loadConstants.m or</span>
0011 <span class="comment">% loadConstantsMine.m files.  numSpots variable in no longer used.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% data.CellA{1}.</span>
0014 <span class="comment">%           mask        : logical (1 and 0) cell mask, unoriented</span>
0015 <span class="comment">%             r_offset    : location of cell in full image from top left corner</span>
0016 <span class="comment">%             BB          : coordinates of cell bounding box, containing the</span>
0017 <span class="comment">%             cell and the pad</span>
0018 <span class="comment">%             edgeFlag    : if the cell is on the edge of the image (bad)</span>
0019 <span class="comment">%             phase        : the cropped phase image of the cell</span>
0020 <span class="comment">%             coord        : coordinates, area, and orientation, see below</span>
0021 <span class="comment">%             length        : (1) length and (2) width of the cell</span>
0022 <span class="comment">%             pole        : orientation of the cell pole, see below</span>
0023 <span class="comment">%             fluor1        : the 1st fluor channel image</span>
0024 <span class="comment">%             fuor1mm     : min and max of fluor1</span>
0025 <span class="comment">%             fl1         : statistics of fluor1, e.g. background level</span>
0026 <span class="comment">%             fluor2        : the 2nd fluor channel image</span>
0027 <span class="comment">%             fluor2mm    : min and max of fluor2</span>
0028 <span class="comment">%             fl2         : statistics of fluor2</span>
0029 <span class="comment">%             cell_dist    : ?</span>
0030 <span class="comment">%             gray        : ?</span>
0031 <span class="comment">%             locus1        : If focus fitting was run, data on the fit</span>
0032 <span class="comment">%             (locations, score..), see below</span>
0033 <span class="comment">%             locus2        : Same as above for channel 2</span>
0034 <span class="comment">%             r           : global coordinates of cell centroid (mid-point of cell)</span>
0035 <span class="comment">%             error        : segmentation error list</span>
0036 <span class="comment">%             ehist        : ehist is the sum of all errors in the region?s history</span>
0037 <span class="comment">%           contactHist    : ?</span>
0038 <span class="comment">%           stat0        : stat0 flag that is true if the cell is born without error</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% The coord field contains a lot of cell specific info:</span>
0041 <span class="comment">% data.CellA{1}.coord =</span>
0042 <span class="comment">%         A: Area of cell mask</span>
0043 <span class="comment">%         r_center: geometrical center of the cell</span>
0044 <span class="comment">%         box: coord of box surrounding cell</span>
0045 <span class="comment">%         xaxis: coord of major axis</span>
0046 <span class="comment">%         yaxis:  coord of minor axis</span>
0047 <span class="comment">%         I: Moment of inertia of cell mask</span>
0048 <span class="comment">%         e1: priniple axis (major) unit vector</span>
0049 <span class="comment">%         e2: priniple axis (minor) unit vector</span>
0050 <span class="comment">%         rcm: center of ?mass? position of mask</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% The pole field contains info pertaining to the cell pole and pole ages:</span>
0053 <span class="comment">% data.CellA{1}.pole =</span>
0054 <span class="comment">%        e1: major axis direction.</span>
0055 <span class="comment">%        op_ori: 1 if old pole is in direction of e1</span>
0056 <span class="comment">%             -1 if old pole is in opposite e1</span>
0057 <span class="comment">%        op_age: age of old pole in cell cycles</span>
0058 <span class="comment">%             NaN if no birth is observed</span>
0059 <span class="comment">%        np_age: age of new pole in cell cycles</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% The locus field contains info from locus finding - if it is run.</span>
0062 <span class="comment">% data.CellA{1}.locus1(1) =</span>
0063 <span class="comment">%       r: Spot position in global coords</span>
0064 <span class="comment">%       score: score from spot fit.</span>
0065 <span class="comment">%       intensity: raw intensity</span>
0066 <span class="comment">%       b: spot width from fit</span>
0067 <span class="comment">%       shortaxis: Locus position in local coords (short axis)</span>
0068 <span class="comment">%       longaxis: Spot position in local coords (long axis)</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% INPUT :</span>
0071 <span class="comment">%       dirname: seg folder eg. maindirectory/xy1/seg</span>
0072 <span class="comment">%       CONST: are the segmentation constants.</span>
0073 <span class="comment">%       header : string displayed with information</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% Copyright (C) 2016 Wiggins Lab</span>
0076 <span class="comment">% University of Washington, 2016</span>
0077 <span class="comment">% This file is part of SuperSeggerOpti.</span>
0078 
0079 <span class="keyword">if</span> ~exist(<span class="string">'header'</span>)
0080     header = [];
0081 <span class="keyword">end</span>
0082 
0083 dirseperator = filesep;
0084 <span class="keyword">if</span>(nargin&lt;1 || isempty(dirname))
0085     dirname = <span class="string">'.'</span>;
0086 <span class="keyword">end</span>
0087 dirname = fixDir(dirname;
0088 
0089 
0090 <span class="comment">% Get the track file names...</span>
0091 contents=dir([dirname <span class="string">'*_err.mat'</span>]);
0092 num_im = numel(contents);
0093 
0094 <span class="keyword">if</span> CONST.show_status
0095     h = waitbar( 0, <span class="string">'Making Cells.'</span>);
0096 <span class="keyword">else</span>
0097     h = [];
0098 <span class="keyword">end</span>
0099 
0100 <span class="comment">% loop through all the cells.</span>
0101 <span class="keyword">for</span> i = 1:num_im;
0102     
0103     <span class="keyword">if</span> (i ==1) &amp;&amp; (1 == num_im)
0104         data_r = [];
0105         data_c = <a href="#_sub1" class="code" title="subfunction data = loaderInternal(filename);">loaderInternal</a>([dirname,contents(i  ).name]);
0106         data_f = [];
0107     <span class="keyword">elseif</span> i == 1;
0108         data_c = <a href="#_sub1" class="code" title="subfunction data = loaderInternal(filename);">loaderInternal</a>([dirname,contents(i  ).name]);
0109         data_f = <a href="#_sub1" class="code" title="subfunction data = loaderInternal(filename);">loaderInternal</a>([dirname,contents(i+1).name]);
0110         data_r = [];
0111     <span class="keyword">elseif</span> i==num_im;
0112         data_c = <a href="#_sub1" class="code" title="subfunction data = loaderInternal(filename);">loaderInternal</a>([dirname,contents(i  ).name]);
0113         data_f = [];
0114         data_r = <a href="#_sub1" class="code" title="subfunction data = loaderInternal(filename);">loaderInternal</a>([dirname,contents(i-1).name]);
0115     <span class="keyword">else</span>
0116         data_c = <a href="#_sub1" class="code" title="subfunction data = loaderInternal(filename);">loaderInternal</a>([dirname,contents(i  ).name]);
0117         data_f = <a href="#_sub1" class="code" title="subfunction data = loaderInternal(filename);">loaderInternal</a>([dirname,contents(i+1).name]);
0118         data_r = <a href="#_sub1" class="code" title="subfunction data = loaderInternal(filename);">loaderInternal</a>([dirname,contents(i-1).name]);
0119     <span class="keyword">end</span>
0120     
0121     <span class="keyword">if</span> i==1;
0122         nc = 0;
0123         tmp_fn = fieldnames( data_c );
0124         nf = numel( tmp_fn );
0125         <span class="keyword">for</span> j = 1:nf;
0126             <span class="keyword">if</span>(strfind(tmp_fn{j},<span class="string">'fluor'</span>)==1)
0127                 nc = nc+1;
0128             <span class="keyword">end</span>
0129         <span class="keyword">end</span>
0130     <span class="keyword">end</span>
0131     
0132     <span class="comment">% set min max.</span>
0133     <span class="keyword">for</span> j = 1:nc
0134         tmp   = getfield( data_c,[<span class="string">'fluor'</span>,num2str(j)]);
0135         ff(j,:) = [min(tmp(:)),max(tmp(:))];
0136     <span class="keyword">end</span>
0137     
0138     <span class="comment">% make the cell array holding the cells that has one element for each</span>
0139     <span class="comment">% region.</span>
0140     data_c.CellA = cell(1,data_c.regs.num_regs);
0141     dist_mask = <a href="makeColonyDist.html" class="code" title="function dist_mask = makeColonyDist( mask )">makeColonyDist</a>( data_c.mask_bg );
0142     
0143     <span class="keyword">for</span> ii = 1:data_c.regs.num_regs
0144         <span class="comment">% Cut out a region with pixel pad size PAD_SIZE.</span>
0145         celld = struct();
0146         PAD_SIZE = 5;
0147         ss = size(data_c.phase);
0148         
0149         [xx,yy]        = getBBpad( data_c.regs.props(ii).BoundingBox, ss, PAD_SIZE);
0150         celld.mask     = logical(data_c.regs.regs_label(yy,xx)==ii);
0151         celld.r_offset = [xx(1),yy(1)];
0152         celld.BB       = [xx(1),yy(1),xx(end)-xx(1),yy(end)-yy(1)];
0153         tmpEdge = [ ceil(data_c.regs.props(ii).BoundingBox(1)),<span class="keyword">...</span>
0154             ceil(data_c.regs.props(ii).BoundingBox(2)),<span class="keyword">...</span>
0155             floor(sum(data_c.regs.props(ii).BoundingBox([1,3]))),<span class="keyword">...</span>
0156             floor(sum(data_c.regs.props(ii).BoundingBox([2,4])))];
0157         celld.edgeFlag = any( tmpEdge == [1,1,ss(2),ss(1)]);
0158         
0159         <span class="comment">% copy information from regions</span>
0160         <span class="keyword">if</span> CONST.trackOpti.NEIGHBOR_FLAG
0161             celld.contactHist = data_c.regs.contactHist(ii);
0162         <span class="keyword">end</span>
0163         
0164         
0165         <span class="comment">% record the number of cell neighbors</span>
0166         <span class="keyword">if</span> CONST.trackOpti.NEIGHBOR_FLAG
0167             nei_ = numel(trackOptiNeighbors(data_c,ii));
0168             data_c.regs.numNeighbors{ii} = nei_ ;
0169             celld.numNeighbors = nei_ ;
0170         <span class="keyword">end</span>
0171         
0172         celld.phase     = data_c.phase(yy,xx);
0173         
0174         <span class="comment">% Keep track of pole age and what direction the old pole is in.</span>
0175         <span class="keyword">if</span> isempty(data_r) || isempty(data_c.regs.map.r{ii})
0176             celld             = <a href="toMakeCell.html" class="code" title="function celld = toMakeCell(celld, e1_old, props)">toMakeCell</a>(celld,[],data_c.regs.props(ii));
0177             celld.pole.e1     = celld.coord.e1;
0178             
0179             celld.pole.op_ori =   0;
0180             celld.pole.op_age = NaN;
0181             celld.pole.np_age = NaN;
0182         <span class="keyword">else</span>
0183             <span class="keyword">if</span> data_c.regs.error.r(ii)
0184                 <span class="keyword">try</span>
0185                     celld             = <a href="toMakeCell.html" class="code" title="function celld = toMakeCell(celld, e1_old, props)">toMakeCell</a>(celld, data_r.CellA{data_c.regs.map.r{ii}(1)}.pole.e1,data_c.regs.props(ii));
0186                 <span class="keyword">catch</span>
0187                     <span class="string">'hi'</span>;
0188                 <span class="keyword">end</span>
0189                 celld.pole.e1     = celld.coord.e1;
0190                 
0191                 celld.pole.op_ori =   0;
0192                 celld.pole.op_age = NaN;
0193                 celld.pole.np_age = NaN;
0194                 
0195             <span class="keyword">elseif</span> data_c.regs.birthF(ii) &amp;&amp; ( data_c.regs.sisterID(ii) ) &amp;&amp; ~isempty(find( data_c.regs.sisterID(ii) == data_c.regs.ID ))
0196                 
0197                 cell_old = data_r.CellA{data_c.regs.map.r{ii}(1)};
0198                 
0199                 celld             = <a href="toMakeCell.html" class="code" title="function celld = toMakeCell(celld, e1_old, props)">toMakeCell</a>(celld, cell_old.pole.e1,data_c.regs.props(ii));
0200                 celld.pole.e1     = celld.coord.e1;
0201                 e1 = celld.pole.e1;
0202                 op_ori = cell_old.pole.op_ori;
0203                 
0204                 
0205                 jj = find( data_c.regs.sisterID(ii) == data_c.regs.ID );
0206                 
0207                 
0208                 jj = jj(1);
0209                 rs = data_c.regs.props(jj).Centroid;
0210                 r0 = data_c.regs.props(ii).Centroid;
0211                 
0212                 dr = (r0-rs)*e1;
0213                 
0214                 celld.pole.op_ori = sign(dr);
0215                 <span class="keyword">if</span> celld.pole.op_ori == cell_old.pole.op_ori
0216                     celld.pole.op_age = cell_old.pole.op_age+1;
0217                 <span class="keyword">else</span>
0218                     celld.pole.op_age = cell_old.pole.np_age+1;
0219                 <span class="keyword">end</span>
0220                 celld.pole.np_age = 1;
0221                 
0222                 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0223                 <span class="comment">% This region of the code is only turned on for debugging</span>
0224                 <span class="comment">% purposes.</span>
0225                 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0226                 debug_flag = 0;
0227                 <span class="keyword">if</span> debug_flag
0228                     clf;
0229                     
0230                     kk = find( data_c.regs.motherID(ii) == data_r.ID );
0231                     
0232                     imshow( 0.5*cat(3, ag(data_c.regs.regs_label==jj), ag(data_c.regs.regs_label==ii),ag(data_r.regs_label==kk)));
0233                     hold on;
0234                     
0235                     tmp = celld;
0236                     r = tmp.coord.r_center;
0237                     xaxisx = r(1) + [0,tmp.length(1)*tmp.coord.e1(1)]/2;
0238                     xaxisy = r(2) + [0,tmp.length(1)*tmp.coord.e1(2)]/2;
0239                     yaxisx = r(1) + [0,tmp.length(2)*tmp.coord.e2(1)]/2;
0240                     yaxisy = r(2) + [0,tmp.length(2)*tmp.coord.e2(2)]/2;
0241                     old_pole = r + tmp.length(1)*tmp.coord.e1'*tmp.pole.op_ori/2;
0242                     new_pole = r - tmp.length(1)*tmp.coord.e1'*tmp.pole.op_ori/2;
0243                     
0244                     plot( r(1), r(2), <span class="string">'g.'</span>);
0245                     plot( xaxisx, xaxisy, <span class="string">'g-'</span>);
0246                     plot( yaxisx, yaxisy, <span class="string">'g-'</span>);
0247                     plot( old_pole(1), old_pole(2), <span class="string">'r.'</span>);
0248                     plot( new_pole(1), new_pole(2), <span class="string">'w.'</span>);
0249                     
0250                     tmp = data_r.CellA{kk};
0251                     r = tmp.coord.r_center;
0252                     r = tmp.coord.r_center;
0253                     xaxisx = r(1) + [0,tmp.length(1)*tmp.coord.e1(1)]/2;
0254                     xaxisy = r(2) + [0,tmp.length(1)*tmp.coord.e1(2)]/2;
0255                     yaxisx = r(1) + [0,tmp.length(2)*tmp.coord.e2(1)]/2;
0256                     yaxisy = r(2) + [0,tmp.length(2)*tmp.coord.e2(2)]/2;
0257                     old_pole = r + tmp.length(1)*tmp.coord.e1'*tmp.pole.op_ori/2;
0258                     new_pole = r - tmp.length(1)*tmp.coord.e1'*tmp.pole.op_ori/2;
0259                     
0260                     plot( r(1), r(2), <span class="string">'g.'</span>);
0261                     plot( xaxisx, xaxisy, <span class="string">'g-'</span>);
0262                     plot( yaxisx, yaxisy, <span class="string">'g-'</span>);
0263                     <span class="keyword">if</span> ~tmp.pole.op_ori
0264                         plot( old_pole(1), old_pole(2), <span class="string">'r.'</span>);
0265                         plot( new_pole(1), new_pole(2), <span class="string">'w.'</span>);
0266                     <span class="keyword">end</span>
0267                     <span class="string">''</span>;
0268                 <span class="keyword">end</span>
0269             <span class="keyword">else</span>
0270                 celld             = <a href="toMakeCell.html" class="code" title="function celld = toMakeCell(celld, e1_old, props)">toMakeCell</a>(celld, data_r.CellA{data_c.regs.map.r{ii}(1)}.pole.e1,data_c.regs.props(ii));
0271                 celld.pole        = data_r.CellA{data_c.regs.map.r{ii}(1)}.pole;
0272                 celld.pole.e1     = celld.coord.e1;
0273             <span class="keyword">end</span>
0274         <span class="keyword">end</span>
0275         
0276         
0277         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0278         <span class="comment">%</span>
0279         <span class="comment">% copy fluor fields, compute fluor statistics, and find loci</span>
0280         <span class="comment">%</span>
0281         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0282         
0283         <span class="keyword">for</span> j = 1:nc
0284             tmp   = getfield( data_c,[<span class="string">'fluor'</span>,num2str(j)]);
0285             celld = setfield( celld, [<span class="string">'fluor'</span>,num2str(j)], tmp(yy,xx));
0286             celld = setfield( celld, [<span class="string">'fluor'</span>,num2str(j),<span class="string">'mm'</span>], ff(j,:) );
0287             
0288             <span class="keyword">if</span> isfield( CONST.trackLoci, <span class="string">'fluorFlag'</span> ) &amp;&amp; CONST.trackLoci.fluorFlag
0289                 tmp = trackOptiCellFluor( tmp(yy,xx), celld.mask, celld.r_offset);
0290             <span class="keyword">else</span>
0291                 tmp = [];
0292             <span class="keyword">end</span>
0293             
0294             tmp = setfield(tmp,<span class="string">'bg'</span>, getfield(data_c, [<span class="string">'fl'</span>,num2str(j),<span class="string">'bg'</span>] ));
0295             celld = setfield( celld, [<span class="string">'fl'</span>,num2str(j)], tmp );
0296             
0297         <span class="keyword">end</span>
0298         
0299         <span class="comment">% compute the distance to the edge of the colony</span>
0300         <span class="keyword">if</span> data_c.regs.ID(ii)
0301             
0302             [xx,yy]        = getBBpad( data_c.regs.props(ii).BoundingBox, ss, 0);
0303             mask_cell      = logical(data_c.regs.regs_label(yy,xx)==ii);
0304             dist_mask_crop = dist_mask(yy,xx);
0305             cell_dist      = min(dist_mask_crop(mask_cell));
0306             celld.cell_dist = cell_dist;
0307             
0308             <span class="comment">% calculate average phase gray val in cell region</span>
0309             celld.gray = mean(double(celld.phase(celld.mask)));
0310             
0311         <span class="keyword">end</span>
0312         data_c.CellA{ii} = celld;
0313         
0314     <span class="keyword">end</span>
0315     
0316     <span class="comment">% save the updated err files.</span>
0317     dataname = [dirname,contents(i  ).name];
0318     save(dataname,<span class="string">'-STRUCT'</span>,<span class="string">'data_c'</span>);
0319     
0320     <span class="keyword">if</span> CONST.show_status
0321         waitbar(i/num_im,h,[<span class="string">'Making Cells--Frame: '</span>,num2str(i),<span class="string">'/'</span>,num2str(num_im)]);
0322     <span class="keyword">else</span>
0323         disp([header, <span class="string">'MakeCell frame: '</span>,num2str(i),<span class="string">' of '</span>,num2str(num_im)]);
0324     <span class="keyword">end</span>
0325 <span class="keyword">end</span>
0326 <span class="keyword">if</span> CONST.show_status
0327     close(h);
0328 <span class="keyword">end</span>
0329 <span class="keyword">end</span>
0330 
0331 <a name="_sub1" href="#_subfunctions" class="code">function data = loaderInternal(filename);</a>
0332 data = load( filename );
0333 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 23-Feb-2016 13:44:44 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of dftregistration</title>
  <meta name="keywords" content="dftregistration">
  <meta name="description" content="dftregistration : Efficient subpixel image registration by crosscorrelation.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">SuperSeggerOpti_Release</a> &gt; <a href="index.html">Internal</a> &gt; dftregistration.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for SuperSeggerOpti_Release/Internal&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>dftregistration
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>dftregistration : Efficient subpixel image registration by crosscorrelation.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [output Greg] = dftregistration(buf1ft,buf2ft,usfac) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> dftregistration : Efficient subpixel image registration by crosscorrelation. 
 This code gives the same precision as the FFT upsampled cross correlation in a
 small fraction of the computation time and with reduced memory 
 requirements. It obtains an initial estimate of the crosscorrelation peak
 by an FFT and then refines the shift estimation by upsampling the DFT
 only in a small neighborhood of that estimate by means of a 
 matrix-multiply DFT. With this procedure all the image points are used to
 compute the upsampled crosscorrelation.
 Manuel Guizar - Dec 13, 2007</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="intAlignIm.html" class="code" title="function  [out, errNum, focusNum] = intAlignIm( imA, imB, precision )">intAlignIm</a>	intAlignIm : aligning image A to image B with given precision</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function out=dftups(in,nor,noc,usfac,roff,coff)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 
0002 <a name="_sub0" href="#_subfunctions" class="code">function [output Greg] = dftregistration(buf1ft,buf2ft,usfac)</a>
0003 <span class="comment">% dftregistration : Efficient subpixel image registration by crosscorrelation.</span>
0004 <span class="comment">% This code gives the same precision as the FFT upsampled cross correlation in a</span>
0005 <span class="comment">% small fraction of the computation time and with reduced memory</span>
0006 <span class="comment">% requirements. It obtains an initial estimate of the crosscorrelation peak</span>
0007 <span class="comment">% by an FFT and then refines the shift estimation by upsampling the DFT</span>
0008 <span class="comment">% only in a small neighborhood of that estimate by means of a</span>
0009 <span class="comment">% matrix-multiply DFT. With this procedure all the image points are used to</span>
0010 <span class="comment">% compute the upsampled crosscorrelation.</span>
0011 <span class="comment">% Manuel Guizar - Dec 13, 2007</span>
0012 
0013 <span class="comment">% Portions of this code were taken from code written by Ann M. Kowalczyk</span>
0014 <span class="comment">% and James R. Fienup.</span>
0015 <span class="comment">% J.R. Fienup and A.M. Kowalczyk, &quot;Phase retrieval for a complex-valued</span>
0016 <span class="comment">% object by using a low-resolution image,&quot; J. Opt. Soc. Am. A 7, 450-458</span>
0017 <span class="comment">% (1990).</span>
0018 
0019 <span class="comment">% Citation for this algorithm:</span>
0020 <span class="comment">% Manuel Guizar-Sicairos, Samuel T. Thurman, and James R. Fienup,</span>
0021 <span class="comment">% &quot;Efficient subpixel image registration algorithms,&quot; Opt. Lett. 33,</span>
0022 <span class="comment">% 156-158 (2008).</span>
0023 
0024 <span class="comment">% Inputs</span>
0025 <span class="comment">% buf1ft    Fourier transform of reference image,</span>
0026 <span class="comment">%           DC in (1,1)   [DO NOT FFTSHIFT]</span>
0027 <span class="comment">% buf2ft    Fourier transform of image to register,</span>
0028 <span class="comment">%           DC in (1,1) [DO NOT FFTSHIFT]</span>
0029 <span class="comment">% usfac     Upsampling factor (integer). Images will be registered to</span>
0030 <span class="comment">%           within 1/usfac of a pixel. For example usfac = 20 means the</span>
0031 <span class="comment">%           images will be registered within 1/20 of a pixel. (default = 1)</span>
0032 
0033 <span class="comment">% Outputs</span>
0034 <span class="comment">% output =  [error,diffphase,net_row_shift,net_col_shift]</span>
0035 <span class="comment">% error     Translation invariant normalized RMS error between f and g</span>
0036 <span class="comment">% diffphase     Global phase difference between the two images (should be</span>
0037 <span class="comment">%               zero if images are non-negative).</span>
0038 <span class="comment">% net_row_shift net_col_shift   Pixel shifts between images</span>
0039 <span class="comment">% Greg      (Optional) Fourier transform of registered version of buf2ft,</span>
0040 <span class="comment">%           the global phase difference is compensated for.</span>
0041 
0042 <span class="comment">% Default usfac to 1</span>
0043 <span class="keyword">if</span> exist(<span class="string">'usfac'</span>)~=1, usfac=1; <span class="keyword">end</span>
0044 
0045 <span class="comment">% Compute error for no pixel shift</span>
0046 <span class="keyword">if</span> usfac == 0,
0047     CCmax = sum(sum(buf1ft.*conj(buf2ft))); 
0048     rfzero = sum(abs(buf1ft(:)).^2);
0049     rgzero = sum(abs(buf2ft(:)).^2); 
0050     error = 1.0 - CCmax.*conj(CCmax)/(rgzero*rfzero); 
0051     error = sqrt(abs(error));
0052     diffphase=atan2(imag(CCmax),real(CCmax)); 
0053     output=[error,diffphase];
0054         
0055 <span class="comment">% Whole-pixel shift - Compute crosscorrelation by an IFFT and locate the</span>
0056 <span class="comment">% peak</span>
0057 <span class="keyword">elseif</span> usfac == 1,
0058     [m,n]=size(buf1ft);
0059     CC = ifft2(buf1ft.*conj(buf2ft));
0060     [max1,loc1] = max(CC);
0061     [max2,loc2] = max(max1);
0062     rloc=loc1(loc2);
0063     cloc=loc2;
0064     CCmax=CC(rloc,cloc); 
0065     rfzero = sum(abs(buf1ft(:)).^2)/(m*n);
0066     rgzero = sum(abs(buf2ft(:)).^2)/(m*n); 
0067     error = 1.0 - CCmax.*conj(CCmax)/(rgzero(1,1)*rfzero(1,1));
0068     error = sqrt(abs(error));
0069     diffphase=atan2(imag(CCmax),real(CCmax)); 
0070     md2 = fix(m/2); 
0071     nd2 = fix(n/2);
0072     <span class="keyword">if</span> rloc &gt; md2
0073         row_shift = rloc - m - 1;
0074     <span class="keyword">else</span>
0075         row_shift = rloc - 1;
0076     <span class="keyword">end</span>
0077 
0078     <span class="keyword">if</span> cloc &gt; nd2
0079         col_shift = cloc - n - 1;
0080     <span class="keyword">else</span>
0081         col_shift = cloc - 1;
0082     <span class="keyword">end</span>
0083     output=[error,diffphase,row_shift,col_shift];
0084     
0085 <span class="comment">% Partial-pixel shift</span>
0086 <span class="keyword">else</span>
0087     
0088     <span class="comment">% First upsample by a factor of 2 to obtain initial estimate</span>
0089     <span class="comment">% Embed Fourier data in a 2x larger array</span>
0090     [m,n]=size(buf1ft);
0091     mlarge=m*2;
0092     nlarge=n*2;
0093     CC=zeros(mlarge,nlarge);
0094     CC(m+1-fix(m/2):m+1+fix((m-1)/2),n+1-fix(n/2):n+1+fix((n-1)/2)) = <span class="keyword">...</span>
0095         fftshift(buf1ft).*conj(fftshift(buf2ft));
0096   
0097     <span class="comment">% Compute crosscorrelation and locate the peak</span>
0098     CC = ifft2(ifftshift(CC)); <span class="comment">% Calculate cross-correlation</span>
0099     [max1,loc1] = max(CC);
0100     [max2,loc2] = max(max1);
0101     rloc=loc1(loc2);cloc=loc2;
0102     CCmax=CC(rloc,cloc);
0103     
0104     <span class="comment">% Obtain shift in original pixel grid from the position of the</span>
0105     <span class="comment">% crosscorrelation peak</span>
0106     [m,n] = size(CC); md2 = fix(m/2); nd2 = fix(n/2);
0107     <span class="keyword">if</span> rloc &gt; md2 
0108         row_shift = rloc - m - 1;
0109     <span class="keyword">else</span>
0110         row_shift = rloc - 1;
0111     <span class="keyword">end</span>
0112     <span class="keyword">if</span> cloc &gt; nd2
0113         col_shift = cloc - n - 1;
0114     <span class="keyword">else</span>
0115         col_shift = cloc - 1;
0116     <span class="keyword">end</span>
0117     row_shift=row_shift/2;
0118     col_shift=col_shift/2;
0119 
0120     <span class="comment">% If upsampling &gt; 2, then refine estimate with matrix multiply DFT</span>
0121     <span class="keyword">if</span> usfac &gt; 2,
0122         <span class="comment">%%% DFT computation %%%</span>
0123         <span class="comment">% Initial shift estimate in upsampled grid</span>
0124         row_shift = round(row_shift*usfac)/usfac; 
0125         col_shift = round(col_shift*usfac)/usfac;     
0126         dftshift = fix(ceil(usfac*1.5)/2); <span class="comment">%% Center of output array at dftshift+1</span>
0127         <span class="comment">% Matrix multiply DFT around the current shift estimate</span>
0128         CC = conj(<a href="#_sub1" class="code" title="subfunction out=dftups(in,nor,noc,usfac,roff,coff)">dftups</a>(buf2ft.*conj(buf1ft),ceil(usfac*1.5),ceil(usfac*1.5),usfac,<span class="keyword">...</span>
0129             dftshift-row_shift*usfac,dftshift-col_shift*usfac))/(md2*nd2*usfac^2);
0130         <span class="comment">% Locate maximum and map back to original pixel grid</span>
0131         [max1,loc1] = max(CC);   
0132         [max2,loc2] = max(max1); 
0133         rloc = loc1(loc2); cloc = loc2;
0134         CCmax = CC(rloc,cloc);
0135         rg00 = <a href="#_sub1" class="code" title="subfunction out=dftups(in,nor,noc,usfac,roff,coff)">dftups</a>(buf1ft.*conj(buf1ft),1,1,usfac)/(md2*nd2*usfac^2);
0136         rf00 = <a href="#_sub1" class="code" title="subfunction out=dftups(in,nor,noc,usfac,roff,coff)">dftups</a>(buf2ft.*conj(buf2ft),1,1,usfac)/(md2*nd2*usfac^2);  
0137         rloc = rloc - dftshift - 1;
0138         cloc = cloc - dftshift - 1;
0139         row_shift = row_shift + rloc/usfac;
0140         col_shift = col_shift + cloc/usfac;    
0141 
0142     <span class="comment">% If upsampling = 2, no additional pixel shift refinement</span>
0143     <span class="keyword">else</span>    
0144         rg00 = sum(sum( buf1ft.*conj(buf1ft) ))/m/n;
0145         rf00 = sum(sum( buf2ft.*conj(buf2ft) ))/m/n;
0146     <span class="keyword">end</span>
0147     error = 1.0 - CCmax.*conj(CCmax)/(rg00*rf00);
0148     error = sqrt(abs(error));
0149     diffphase=atan2(imag(CCmax),real(CCmax));
0150     <span class="comment">% If its only one row or column the shift along that dimension has no</span>
0151     <span class="comment">% effect. We set to zero.</span>
0152     <span class="keyword">if</span> md2 == 1,
0153         row_shift = 0;
0154     <span class="keyword">end</span>
0155     <span class="keyword">if</span> nd2 == 1,
0156         col_shift = 0;
0157     <span class="keyword">end</span>
0158     output=[error,diffphase,row_shift,col_shift];
0159 <span class="keyword">end</span>  
0160 
0161 <span class="comment">% Compute registered version of buf2ft</span>
0162 <span class="keyword">if</span> (nargout &gt; 1)&amp;&amp;(usfac &gt; 0),
0163     [nr,nc]=size(buf2ft);
0164     Nr = ifftshift([-fix(nr/2):ceil(nr/2)-1]);
0165     Nc = ifftshift([-fix(nc/2):ceil(nc/2)-1]);
0166     [Nc,Nr] = meshgrid(Nc,Nr);
0167     Greg = buf2ft.*exp(i*2*pi*(-row_shift*Nr/nr-col_shift*Nc/nc));
0168     Greg = Greg*exp(i*diffphase);
0169 <span class="keyword">elseif</span> (nargout &gt; 1)&amp;&amp;(usfac == 0)
0170     Greg = buf2ft*exp(i*diffphase);
0171 <span class="keyword">end</span>
0172 <span class="keyword">return</span>
0173 
0174 <a name="_sub1" href="#_subfunctions" class="code">function out=dftups(in,nor,noc,usfac,roff,coff)</a>
0175 <span class="comment">% function out=dftups(in,nor,noc,usfac,roff,coff);</span>
0176 <span class="comment">% Upsampled DFT by matrix multiplies, can compute an upsampled DFT in just</span>
0177 <span class="comment">% a small region.</span>
0178 <span class="comment">% usfac         Upsampling factor (default usfac = 1)</span>
0179 <span class="comment">% [nor,noc]     Number of pixels in the output upsampled DFT, in</span>
0180 <span class="comment">%               units of upsampled pixels (default = size(in))</span>
0181 <span class="comment">% roff, coff    Row and column offsets, allow to shift the output array to</span>
0182 <span class="comment">%               a region of interest on the DFT (default = 0)</span>
0183 <span class="comment">% Recieves DC in upper left corner, image center must be in (1,1)</span>
0184 <span class="comment">% Manuel Guizar - Dec 13, 2007</span>
0185 <span class="comment">% Modified from dftus, by J.R. Fienup 7/31/06</span>
0186 
0187 <span class="comment">% This code is intended to provide the same result as if the following</span>
0188 <span class="comment">% operations were performed</span>
0189 <span class="comment">%   - Embed the array &quot;in&quot; in an array that is usfac times larger in each</span>
0190 <span class="comment">%     dimension. ifftshift to bring the center of the image to (1,1).</span>
0191 <span class="comment">%   - Take the FFT of the larger array</span>
0192 <span class="comment">%   - Extract an [nor, noc] region of the result. Starting with the</span>
0193 <span class="comment">%     [roff+1 coff+1] element.</span>
0194 
0195 <span class="comment">% It achieves this result by computing the DFT in the output array without</span>
0196 <span class="comment">% the need to zeropad. Much faster and memory efficient than the</span>
0197 <span class="comment">% zero-padded FFT approach if [nor noc] are much smaller than [nr*usfac nc*usfac]</span>
0198 
0199 [nr,nc]=size(in);
0200 <span class="comment">% Set defaults</span>
0201 <span class="keyword">if</span> exist(<span class="string">'roff'</span>)~=1, roff=0; <span class="keyword">end</span>
0202 <span class="keyword">if</span> exist(<span class="string">'coff'</span>)~=1, coff=0; <span class="keyword">end</span>
0203 <span class="keyword">if</span> exist(<span class="string">'usfac'</span>)~=1, usfac=1; <span class="keyword">end</span>
0204 <span class="keyword">if</span> exist(<span class="string">'noc'</span>)~=1, noc=nc; <span class="keyword">end</span>
0205 <span class="keyword">if</span> exist(<span class="string">'nor'</span>)~=1, nor=nr; <span class="keyword">end</span>
0206 <span class="comment">% Compute kernels and obtain DFT by matrix products</span>
0207 kernc=exp((-i*2*pi/(nc*usfac))*( ifftshift([0:nc-1]).' - floor(nc/2) )*( [0:noc-1] - coff ));
0208 kernr=exp((-i*2*pi/(nr*usfac))*( [0:nor-1].' - roff )*( ifftshift([0:nr-1]) - floor(nr/2)  ));
0209 out=kernr*in*kernc;
0210 <span class="keyword">return</span></pre></div>
<hr><address>Generated on Tue 23-Feb-2016 13:44:44 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>
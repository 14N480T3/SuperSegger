<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of compSpotPosDevFmin</title>
  <meta name="keywords" content="compSpotPosDevFmin">
  <meta name="description" content="compSpotPosDevFmin does all the work for locus fitting from the fluorescence">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">SuperSeggerRelease</a> &gt; <a href="index.html">locusTrack</a> &gt; compSpotPosDevFmin.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for SuperSeggerRelease/locusTrack&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>compSpotPosDevFmin
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>compSpotPosDevFmin does all the work for locus fitting from the fluorescence</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [spot] = compSpotPosDevFmin(image, im_mask, MAX_NUM_SPOT,CONST, channel, disp_flag, fig_num, opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> compSpotPosDevFmin does all the work for locus fitting from the fluorescence
 image. Resizes the masks, adds padding, and uses watersheds and gaussian
 fit to find the loci.

 INPUT :
   image: fluorescence image
   im_mask: cell mask
   MAX_NUM_SPOT : number of loci to be found, set by the segmentation contants
   CONST : are the segmentation constants
   channel : is the cell file
   disp_flag : display figures
   fig_num : figure number where fits will be displayed
   opt : options to set parameters for fminsearch (Multidimensional
   unconstrained nonlinear minimization)

 OUTPUT :
   spot : information about loci found sorted by highest intensity first.
   spot.r : the global coordinates of the focus center 
   score : the score, max intensity of foci divided by the width of the fit function
   spot.intensity    : raw intensity
   spot.b            : width of the fit function
   spot.shortaxis        : short axis position (in pixels)
   spot.longaxis        : long axis position (in pixels)

 Copyright (C) 2016 Wiggins Lab
 University of Washington, 2016
 This file is part of SuperSeggerOpti.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="intTrackSpots.html" class="code" title="function locus = intTrackSpots(fluor, numLoci, celld, CONST);">intTrackSpots</a>	intTrackSpots : Fits locus positions from the fluorescence</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function C = do_the_fit( ddd )</a></li><li><a href="#_sub2" class="code">function C = g_fit_fun(X,Y,x0,y0,IG,I0,b1)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [spot] = compSpotPosDevFmin(image, im_mask, MAX_NUM_SPOT, </a><span class="keyword">...</span>
0002     CONST, channel, disp_flag, fig_num, opt)
0003 <span class="comment">% compSpotPosDevFmin does all the work for locus fitting from the fluorescence</span>
0004 <span class="comment">% image. Resizes the masks, adds padding, and uses watersheds and gaussian</span>
0005 <span class="comment">% fit to find the loci.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% INPUT :</span>
0008 <span class="comment">%   image: fluorescence image</span>
0009 <span class="comment">%   im_mask: cell mask</span>
0010 <span class="comment">%   MAX_NUM_SPOT : number of loci to be found, set by the segmentation contants</span>
0011 <span class="comment">%   CONST : are the segmentation constants</span>
0012 <span class="comment">%   channel : is the cell file</span>
0013 <span class="comment">%   disp_flag : display figures</span>
0014 <span class="comment">%   fig_num : figure number where fits will be displayed</span>
0015 <span class="comment">%   opt : options to set parameters for fminsearch (Multidimensional</span>
0016 <span class="comment">%   unconstrained nonlinear minimization)</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% OUTPUT :</span>
0019 <span class="comment">%   spot : information about loci found sorted by highest intensity first.</span>
0020 <span class="comment">%   spot.r : the global coordinates of the focus center</span>
0021 <span class="comment">%   score : the score, max intensity of foci divided by the width of the fit function</span>
0022 <span class="comment">%   spot.intensity    : raw intensity</span>
0023 <span class="comment">%   spot.b            : width of the fit function</span>
0024 <span class="comment">%   spot.shortaxis        : short axis position (in pixels)</span>
0025 <span class="comment">%   spot.longaxis        : long axis position (in pixels)</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% Copyright (C) 2016 Wiggins Lab</span>
0028 <span class="comment">% University of Washington, 2016</span>
0029 <span class="comment">% This file is part of SuperSeggerOpti.</span>
0030 
0031 <span class="comment">%disp_flag = 1;</span>
0032 gaussR = CONST.trackLoci.gaussR;
0033 crop   = CONST.trackLoci.crop;
0034 
0035 tmp = struct(<span class="keyword">...</span>
0036     <span class="string">'r'</span>, NaN, <span class="keyword">...</span>
0037     <span class="string">'score'</span>, NaN, <span class="keyword">...</span>
0038     <span class="string">'intensity'</span>, NaN, <span class="keyword">...</span>
0039     <span class="string">'b'</span>, NaN );
0040 
0041 spot(MAX_NUM_SPOT) = tmp;
0042 score_array(MAX_NUM_SPOT) = NaN;
0043 
0044 <span class="keyword">persistent</span> sdisk;
0045 <span class="keyword">persistent</span> gauss;
0046 <span class="keyword">persistent</span> Xpre;
0047 <span class="keyword">persistent</span> Ypre;
0048 <span class="keyword">persistent</span> crop_;
0049 
0050 <span class="keyword">if</span> isempty(sdisk)
0051     sdisk =  strel(<span class="string">'disk'</span>,1);
0052     gauss  =  fspecial(<span class="string">'gaussian'</span>,7,gaussR);
0053     <span class="comment">%lap    = -fspecial('laplacian');</span>
0054     <span class="comment">%locusd =  imfilter(gauss, lap);</span>
0055     crop_ = -crop:crop;
0056     [Xpre, Ypre] = meshgrid(crop_,crop_);
0057     
0058 <span class="keyword">end</span>
0059 
0060 <span class="keyword">if</span> ~exist(<span class="string">'disp_flag'</span>, <span class="string">'var'</span>);
0061     disp_flag = 0;
0062 <span class="keyword">end</span>
0063 <span class="keyword">if</span> disp_flag
0064     <span class="keyword">if</span> ~exist(<span class="string">'fig_num'</span>,<span class="string">'var'</span>)
0065         fig_num = 7;
0066     <span class="keyword">end</span>
0067 <span class="keyword">end</span>
0068 
0069 
0070 <span class="comment">%%---------------------------------------------------------%</span>
0071 <span class="comment">% load the images and resize them.</span>
0072 <span class="comment">% the resizing is necessary because the fitting works better</span>
0073 <span class="comment">% when there are many pixels per spot.</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% im_mask_ is an enlarged cell mask to make the fitting</span>
0076 <span class="comment">% more accurate when there are spots near the cell border</span>
0077 <span class="comment">%---------------------------------------------------------</span>
0078 
0079 
0080 image = double(image);
0081 im_mask = logical(im_mask);
0082 
0083 im_mask_dilated = imdilate(im_mask, sdisk);
0084 im_mask_dilated(1,:) = 0;
0085 im_mask_dilated(<span class="keyword">end</span>,:) = 0;
0086 im_mask_dilated(:,1) = 0;
0087 im_mask_dilated(:,end) = 0;
0088 
0089 
0090 imsize = size(image);
0091 
0092 <span class="comment">%---------------------------------------------------------</span>
0093 <span class="comment">%</span>
0094 <span class="comment">% pad the images to facilitate cropping around each spot</span>
0095 <span class="comment">%</span>
0096 <span class="comment">% there are two masks: one for watersheding and one for fitting.</span>
0097 <span class="comment">% the fitting mask is slightly wider to accomodate spots near</span>
0098 <span class="comment">% the cell boundary.</span>
0099 <span class="comment">%</span>
0100 <span class="comment">%---------------------------------------------------------</span>
0101 
0102 im = zeros( imsize(1)+2*crop,imsize(2)+2*crop);
0103 mk = logical(im);
0104 mk_for_fit = logical(im);
0105 
0106 mk(crop+1:crop+imsize(1),crop+1:crop+imsize(2)) = im_mask;
0107 
0108 mk_init = mk;
0109 im(crop+1:crop+imsize(1),crop+1:crop+imsize(2)) = image;
0110 mk_for_fit(crop+1:crop+imsize(1),crop+1:crop+imsize(2)) = im_mask_dilated;
0111 
0112 imLap = double(im);
0113 Istd = std(imLap(logical(mk)));
0114 Imean = mean(imLap(logical(mk)));
0115 
0116 <span class="keyword">if</span> disp_flag
0117     figure(10);
0118     imshow( imLap, [] );
0119     hold on;
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">%---------------------------------------------------------</span>
0123 <span class="comment">%</span>
0124 <span class="comment">% mean and variance of the intensity within the cell</span>
0125 <span class="comment">%</span>
0126 <span class="comment">%---------------------------------------------------------</span>
0127 
0128 Ibar = mean(im(logical(mk)));
0129 dI = std(im(logical(mk)));
0130 
0131 
0132 <span class="comment">%---------------------------------------------------------</span>
0133 <span class="comment">%</span>
0134 <span class="comment">% segment the fluorescent image to obtain regions</span>
0135 <span class="comment">% around each spot.</span>
0136 <span class="comment">%</span>
0137 <span class="comment">%---------------------------------------------------------</span>
0138 
0139 im_loc_raw = zeros( imsize(1)+2*crop,imsize(2)+2*crop);
0140 im_loc_raw(crop+1:crop+imsize(1),crop+1:crop+imsize(2)) = imfilter( image, gauss, <span class="string">'replicate'</span> );
0141 
0142 Imin = min(im_loc_raw(mk_init));
0143 
0144 thresh  = 0;
0145 im_loc  = im_loc_raw-thresh;
0146 im_loc(im_loc&lt;0) = 0;
0147 im_loc(~mk_for_fit) = 0;
0148 
0149 L = watershed(-double(im_loc));
0150 
0151 wr = (L == 0);
0152 num_seg = max((L(:)));
0153 
0154 xn = zeros(num_seg,1);
0155 yn = zeros(num_seg,1);
0156 fn = zeros(num_seg,1);
0157 an = zeros(num_seg,1);
0158 
0159 spot_num = 0;
0160 
0161 LL = L;
0162 
0163 LL(~mk_for_fit) = 0;
0164 
0165 <span class="comment">%---------------------------------------------------------</span>
0166 <span class="comment">%</span>
0167 <span class="comment">% here we look at each watershed region and record</span>
0168 <span class="comment">% the intensity of its spot.</span>
0169 <span class="comment">%</span>
0170 <span class="comment">%---------------------------------------------------------</span>
0171 
0172 <span class="keyword">for</span> j = 1:num_seg;
0173     
0174     mask = (LL==j);
0175     
0176     [maxValue,y] = max(double(im_loc(:)).*double(mask(:)));
0177     [y,x] = ind2sub(size(im),y);
0178     
0179     xn(j) = x;
0180     yn(j) = y;
0181     fn(j)=maxValue;
0182     
0183     an(j) = sum(mask(:));
0184     
0185 <span class="keyword">end</span>
0186 
0187 <span class="comment">%---------------------------------------------------------</span>
0188 <span class="comment">%</span>
0189 <span class="comment">% plots for debugging</span>
0190 <span class="comment">%</span>
0191 <span class="comment">%---------------------------------------------------------</span>
0192 <span class="keyword">if</span> disp_flag
0193     figure(fig_num); clf;
0194     <span class="keyword">if</span> channel == 1
0195         imshow([cat(3,autogain(im),autogain(~mk)*.2,autogain(wr)/2),cat(3,autogain(im),autogain(~mk)*0,0*autogain(wr)/2)],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>)
0196     <span class="keyword">elseif</span> channel == 2
0197         imshow(cat(3,autogain(wr)/2,0.5*autogain(im.*mk),autogain(im.*mk)),<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>)
0198     <span class="keyword">else</span>
0199         imshow(cat(3,autogain(im.*mk)*.75,autogain(im.*mk)*.75,autogain(wr)/2),<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>)
0200     <span class="keyword">end</span>
0201     <span class="comment">%    drawnow;</span>
0202     hold on
0203     <span class="comment">%   axis equal</span>
0204 <span class="keyword">end</span>
0205 
0206 
0207 <span class="comment">%---------------------------------------------------------</span>
0208 <span class="comment">%</span>
0209 <span class="comment">% fit a gaussian to locate the spot within each region</span>
0210 <span class="comment">% only fits the brightest two watersheds</span>
0211 <span class="comment">%---------------------------------------------------------</span>
0212 
0213 
0214 <span class="comment">%background intensity set to zero</span>
0215 <span class="comment">%I0 = sum( double(im(:)).*double(mk(:)) )/sum( double(mk(:)) );</span>
0216 I0 = Ibar-0.5*dI;
0217 
0218 <span class="comment">% thresholds to determine which spots are real</span>
0219 fnn = fn;
0220 
0221 MIN_AREA = 8;
0222 [fnn_, ord] = sort(fnn, <span class="string">'descend'</span>);
0223 an = an(ord);
0224 iis = find(  (fnn_&gt;0) .* (an &gt; MIN_AREA)  );
0225 iis = iis(1:min([MAX_NUM_SPOT,numel(iis)]));
0226 iis = reshape(iis,1,numel(iis));
0227 
0228 <span class="keyword">if</span> ~isempty(iis)
0229     <span class="keyword">for</span> ii = iis
0230         
0231         i = ord(ii);
0232         spot_crop = 1;
0233         mk(yn(i)+(-spot_crop:spot_crop), xn(i)+(-spot_crop:spot_crop)) = 0;
0234         
0235     <span class="keyword">end</span>
0236     
0237     
0238     <span class="comment">%Ibar = mean(im(mk));</span>
0239     dI = std(im(mk));
0240     
0241     
0242     <span class="keyword">for</span> ii = iis
0243         
0244         i = ord(ii);
0245         
0246         x = xn(i);
0247         y = yn(i);
0248         
0249         mask_crop_for_fit = and(bwmorph(LL==i,<span class="string">'dilate'</span>),mk_for_fit);
0250 
0251         <span class="comment">% this is the initial guess for the fit parameters</span>
0252         IG = im(y,x)-I0;
0253         b = 1;
0254         
0255         ddd = [x,y,IG,b];
0256         
0257         <span class="comment">% lower bound</span>
0258         <span class="comment">%lddd = [x-crop,y-crop,0,bmin];</span>
0259         
0260         <span class="comment">% upper bound</span>
0261         <span class="comment">%uddd = [x+crop,y+crop,100000,bmax];</span>
0262         
0263         <span class="comment">% make the coordinates for the cropped image</span>
0264         ix2 = x+crop_;
0265         iy2 = y+crop_;
0266         
0267         xx2 = Xpre+x;
0268         yy2 = Ypre+y;
0269         
0270         <span class="comment">%---------------------------------------------------------</span>
0271         <span class="comment">%</span>
0272         <span class="comment">% here we actually do the fit</span>
0273         <span class="comment">%</span>
0274         <span class="comment">%---------------------------------------------------------</span>
0275         
0276         
0277         mkk = mask_crop_for_fit(iy2,ix2);
0278         imm = im(iy2,ix2);
0279         
0280         [ddd] = fminsearch( @<a href="#_sub1" class="code" title="subfunction C = do_the_fit( ddd )">do_the_fit</a>,ddd,opt);
0281         
0282         <span class="comment">%---------------------------------------------------------</span>
0283         <span class="comment">%</span>
0284         <span class="comment">% extract the position, width, and intensity of the fitted gaussian</span>
0285         <span class="comment">%</span>
0286         <span class="comment">%---------------------------------------------------------</span>
0287         
0288         xpos = ddd(1);
0289         ypos = ddd(2);
0290         IG = ddd(3);
0291         B = ddd(4);
0292         
0293         sz = size(L);
0294         
0295         position_score = mask_crop_for_fit(min(max(1,floor(ypos)),sz(1)), min(max(1,floor(xpos)),sz(2)));
0296         
0297         ssLap = size( imLap );
0298         intx = min([max([1,round(xpos)]),ssLap(2)]);
0299         
0300         inty = min([max([1,round(ypos)]),ssLap(1)]);
0301         
0302         lmk = 0*mk;
0303         lmk( inty, intx ) = 1;
0304         lmk = and(bwmorph(lmk,<span class="string">'dilate'</span>),mk_init);
0305         
0306         Itotal = mean(imLap( lmk ));
0307         score = (Itotal-Imin);
0308         position_score  = score;
0309         raw_intensity = ddd(3);
0310         
0311         <span class="comment">%---------------------------------------------------------</span>
0312         <span class="comment">%</span>
0313         <span class="comment">% only record the spot if the fit looks good</span>
0314         <span class="comment">%</span>
0315         <span class="comment">%---------------------------------------------------------</span>
0316         
0317         <span class="keyword">if</span> score &gt; 0
0318             spot_num = spot_num+1;  
0319             rr(:,i) = [xpos,ypos];
0320             spot(spot_num).r = [xpos-crop,ypos-crop];
0321             spot(spot_num).score = score;
0322             spot(spot_num).intensity = raw_intensity;
0323             spot(spot_num).b = B;
0324             score_array(spot_num) = score;
0325         <span class="keyword">end</span>
0326         
0327         
0328         <span class="comment">%---------------------------------------------------------</span>
0329         <span class="comment">%</span>
0330         <span class="comment">% plots for debugging</span>
0331         <span class="comment">%</span>
0332         <span class="comment">%---------------------------------------------------------</span>
0333         
0334         <span class="keyword">if</span> disp_flag
0335             
0336             <span class="keyword">if</span> score &gt; 0;
0337                 cc = <span class="string">'w'</span>;
0338             <span class="keyword">else</span>
0339                 cc = <span class="string">'b'</span>;
0340             <span class="keyword">end</span>
0341             
0342             
0343             theta = 0;
0344             
0345             figure(fig_num);
0346             plot(xpos,ypos,[cc,<span class="string">'.'</span>]);
0347             plot(x,y,[<span class="string">'y.'</span>]);
0348             
0349             text(xpos+2,ypos,[<span class="string">'s:'</span>, num2str(score,3)],<span class="string">'Color'</span>,cc);
0350             plot(xpos+B*[0,sin(theta)],ypos+B*[0,cos(theta)],[cc,<span class="string">':'</span>]);
0351             plot(xpos+B*[0,cos(theta)],ypos+B*[0,-sin(theta)],[cc,<span class="string">':'</span>]);
0352       
0353             figure(10);
0354             plot(xpos,ypos,[cc,<span class="string">'.'</span>]);
0355             plot(x,y,[<span class="string">'y.'</span>]);
0356             text(xpos+2,ypos,[<span class="string">'s:'</span>, num2str(score,3)],<span class="string">'Color'</span>,<span class="string">'m'</span>);
0357             
0358             pause;
0359         <span class="keyword">end</span>
0360         
0361         <span class="comment">%% fix the mean.</span>
0362         
0363         
0364         
0365     <span class="keyword">end</span>
0366 <span class="keyword">end</span>
0367 
0368 
0369 <span class="comment">% compute the std of the intensity once the loci have bee cropped from the</span>
0370 <span class="comment">% mask mk.</span>
0371 Istd = std(imLap(mk));
0372 
0373 nspot = numel(spot);
0374 score_array = zeros(1,nspot);
0375 
0376 <span class="keyword">for</span> ii = 1:nspot
0377     <span class="keyword">if</span> isempty(spot(ii).score)
0378         spot(ii).score = -100;
0379     <span class="keyword">end</span>
0380     score_array(ii) = spot(ii).score/Istd-1;
0381     spot(ii).score = score_array(ii);
0382     
0383 <span class="keyword">end</span>
0384 
0385 spot = spot(score_array&gt;0);
0386 score_array = score_array(score_array&gt;0);
0387 
0388 <span class="comment">% Sort spots by score so that first spot has the highest score.</span>
0389 [a,b] = sort(score_array,<span class="string">'descend'</span>);
0390 spot = spot(b);
0391 
0392 
0393     <a name="_sub1" href="#_subfunctions" class="code">function C = do_the_fit( ddd )</a>
0394         gg = <a href="#_sub2" class="code" title="subfunction C = g_fit_fun(X,Y,x0,y0,IG,I0,b1)">g_fit_fun</a>(xx2,yy2,ddd(1),ddd(2),ddd(3),I0,ddd(4));
0395         tmp = (double(imm)-gg);<span class="comment">%.*mask_crop_for_fit(iy2,ix2);</span>
0396         C = sum(tmp(logical(mkk)).^2);
0397     <span class="keyword">end</span>
0398 
0399 <span class="keyword">end</span>
0400 
0401 <a name="_sub2" href="#_subfunctions" class="code">function C = g_fit_fun(X,Y,x0,y0,IG,I0,b1)</a>
0402 <span class="comment">% g_fit_fun Gaussian Fit function</span>
0403 C = I0 + IG*exp( -((X-x0).^2+(Y-y0).^2)/(2*b1^2) );
0404 
0405 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 23-Feb-2016 16:32:17 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>